

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>arctern.geoseries.geoseries &mdash; Arctern version : 0.2.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Arctern
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quick_start/quick_start.html">快速开始</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature_description/feature_description.html">功能说明</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/api_reference.html">API 参考</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Arctern</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">模块代码</a> &raquo;</li>
        
      <li>arctern.geoseries.geoseries</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>arctern.geoseries.geoseries 源代码</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2019-2020 Zilliz. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># pylint: disable=useless-super-delegation</span>
<span class="c1"># pylint: disable=too-many-lines</span>
<span class="c1"># pylint: disable=too-many-public-methods</span>
<span class="c1"># pylint: disable=too-many-ancestors, protected-access</span>

<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span><span class="p">,</span> <span class="n">DataFrame</span>
<span class="kn">import</span> <span class="nn">arctern</span>
<span class="kn">from</span> <span class="nn">.geoarray</span> <span class="kn">import</span> <span class="n">GeoArray</span><span class="p">,</span> <span class="n">is_geometry_array</span><span class="p">,</span> <span class="n">GeoDtype</span>


<span class="k">def</span> <span class="nf">fix_dataframe_box_col_volues</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">_box_col_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">GeoDtype</span><span class="p">):</span>
            <span class="n">klass</span> <span class="o">=</span> <span class="n">GeoSeries</span>

        <span class="k">return</span> <span class="n">klass</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">items</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">DataFrame</span><span class="o">.</span><span class="n">_box_col_values</span> <span class="o">=</span> <span class="n">_box_col_values</span>


<span class="n">fix_dataframe_box_col_volues</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_property_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries) -&gt; Series[bool/float/object]</span>
    <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_property_geo</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries) -&gt; GeoSeries</span>
    <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_unary_geo</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries, args, kwargs) -&gt; GeoSeries</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;crs&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_delegate_binary_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries, GeoSeries/bytes) -&gt; GeoSeries/Series</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">GeoSeries</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">this</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The indices of the two GeoSeries are different.&quot;</span><span class="p">)</span>
            <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">this</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">index</span>


<span class="k">def</span> <span class="nf">_binary_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries, GeoSeries/bytes) -&gt; Series[bool/float]</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">_delegate_binary_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_binary_geo</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="c1"># type: (function, GeoSeries, GeoSeries/bytes) -&gt; GeoSeries</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">_delegate_binary_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">this</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`crs` should be spatial reference identifier string&quot;</span><span class="p">)</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">crs</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">crs</span>
    <span class="k">return</span> <span class="n">crs</span>


<div class="viewcode-block" id="GeoSeries"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.html#arctern.GeoSeries">[文档]</a><span class="k">class</span> <span class="nc">GeoSeries</span><span class="p">(</span><span class="n">Series</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Series to store geometry data which is WKB formed bytes object.</span>

<span class="sd">    :type data: array-like, Iterable, dict, or scalar value(str or bytes)</span>
<span class="sd">    :param data: Geometries to store, which can be WKB formed bytes or WKT formed string.</span>

<span class="sd">    :type index: array-like or Index (1d)</span>
<span class="sd">    :param index: Same to Pandas Series.</span>
<span class="sd">        Values must be hashable and have the same length as `data`.</span>
<span class="sd">        Non-unique index values are allowed. Will default to</span>
<span class="sd">        RangeIndex (0, 1, 2, ..., n) if not provided. If both a dict and index</span>
<span class="sd">        sequence are used, the index will override the keys found in the</span>
<span class="sd">        dict.</span>

<span class="sd">    :type name: str, optional</span>
<span class="sd">    :param name: The name to give to the Series.</span>

<span class="sd">    :type crs: str, optional</span>
<span class="sd">    :param crs: The coordinate system for the GeoSeries, now only support SRID form.</span>

<span class="sd">    :param kwargs: Additional arguments passed to the GeoSeries constructor, e.g. ``copy``</span>

<span class="sd">    :example:</span>
<span class="sd">    &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">    &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1 2)&quot;])</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    0    POINT (1 1)</span>
<span class="sd">    1    POINT (1 2)</span>
<span class="sd">    dtype: GeoDtype</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="GeoSeries.__init__"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.html#arctern.GeoSeries.__init__">[文档]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;crs&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">crs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">crs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;csr of the passed geometry data is different from crs.&quot;</span>
                <span class="p">)</span>
        <span class="c1"># scalar wkb or wkt</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_geometry_array</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">index</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
            <span class="c1"># make sure missing value is None</span>
            <span class="n">s</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">infer_dtype</span>
            <span class="n">inferred</span> <span class="o">=</span> <span class="n">infer_dtype</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inferred</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;bytes&quot;</span><span class="p">,</span> <span class="s2">&quot;empty&quot;</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">inferred</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">arctern</span><span class="o">.</span><span class="n">ST_GeomFromText</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can not use no bytes or string data to construct GeoSeries.&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">GeoArray</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_crs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.set_crs"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.set_crs.html#arctern.GeoSeries.set_crs">[文档]</a>    <span class="k">def</span> <span class="nf">set_crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the coordinate system for the GeoSeries.</span>

<span class="sd">        :type crs: str, optional</span>
<span class="sd">        :param crs: SRID(spatial reference identifier) form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_crs</span> <span class="o">=</span> <span class="n">crs</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">crs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crs</span>

    <span class="nd">@crs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the coordinate system for the GeoSeries.</span>

<span class="sd">        :type crs: str, optional</span>
<span class="sd">        :param crs: SRID(spatial reference identifier) form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Some operations result is not geometry type, we should return Series as constructor</span>
        <span class="c1"># e.g.(isna, notna)</span>
        <span class="k">def</span> <span class="nf">_try_constructor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="kn">import</span> <span class="n">SingleBlockManager</span>
                <span class="c1"># astype will dispatch to here,Only if `dtype` is `GeoDtype`</span>
                <span class="c1"># will return GeoSeries</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SingleBlockManager</span><span class="p">):</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">GeoDtype</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span>
                <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_try_constructor</span>

    <span class="c1"># --------------------------------------------------------------------------</span>
    <span class="c1"># override Series method</span>
    <span class="c1"># --------------------------------------------------------------------------</span>

<div class="viewcode-block" id="GeoSeries.equals"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.equals.html#arctern.GeoSeries.equals">[文档]</a>    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether two objects contain the same elements.</span>

<span class="sd">        This function allows two GeoSeries to be compared against each other to</span>
<span class="sd">        see if they have the same shape and geometries (same wkb bytes).</span>
<span class="sd">        NaNs in the same location are considered equal. The column headers do not</span>
<span class="sd">        need to have the same type, but the elements within the columns must</span>
<span class="sd">        be the same dtype.</span>

<span class="sd">        :type other: GeoSeries</span>
<span class="sd">        :param other: The other GeoSeries to be compared with the first</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        :return: True if all geometries are the same in both objects, False otherwise.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POINT(1 1)&quot;, None])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POINT(1 1)&quot;, None])</span>
<span class="sd">        &gt;&gt;&gt; s2.equals(s1)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">GeoSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.fillna"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.fillna.html#arctern.GeoSeries.fillna">[文档]</a>    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NA values with a geometry, which can be WKT or WKB formed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.isna"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.isna.html#arctern.GeoSeries.isna">[文档]</a>    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect missing values.</span>

<span class="sd">        NA value in GeoSeries is represented as None.</span>

<span class="sd">        :rtype: Series(dtype: bool)</span>
<span class="sd">        :return: Mask of bool values for each element in GeoSeries</span>
<span class="sd">                that indicates whether an element is not an NA value.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;Point (1 1)&quot;, None])</span>
<span class="sd">        &gt;&gt;&gt; s.isna()</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span></div>

<div class="viewcode-block" id="GeoSeries.notna"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.notna.html#arctern.GeoSeries.notna">[文档]</a>    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect non-missing values.</span>

<span class="sd">        Inverse of isna.</span>

<span class="sd">        :rtype: Series(dtype: bool)</span>
<span class="sd">        :return: Mask of bool values for each element in GeoSeries</span>
<span class="sd">                that indicates whether an element is not an NA value.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1 1)&quot;, None])</span>
<span class="sd">        &gt;&gt;&gt; s.isna()</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span></div>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related property</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if each geometry is of valid geometry format.</span>

<span class="sd">        :rtype: Series(dtype: bool)</span>
<span class="sd">        :return: True value for geometries that are valid, False otherwise.</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT(1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.is_valid</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_IsValid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the length of each geometry.</span>

<span class="sd">        :rtype: Series(dtype: float64)</span>
<span class="sd">        :return: The length of each geometry in the GeoSeries.</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;LINESTRING (0 0, 0 2)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.length</span>
<span class="sd">        0    0.0</span>
<span class="sd">        1    2.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Length</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether each geometry is &quot;simple&quot;.</span>

<span class="sd">        &quot;Simple&quot; here means that a geometry has no anomalous geometric points,</span>
<span class="sd">        such as self intersection or self tangency.</span>

<span class="sd">        :rtype: Series(dtype: bool)</span>
<span class="sd">        :return: True for geometries that are simple, False otherwise.</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POINT EMPTY&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.is_simple</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_IsSimple</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the 2D Cartesian (planar) area of each geometry.</span>

<span class="sd">        :rtype: Series(dtype: float64)</span>
<span class="sd">        :return: The area of each geometry.</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.area</span>
<span class="sd">        0    0.0</span>
<span class="sd">        1    4.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Area</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geom_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry in geometries, return a string that indicates is type.</span>

<span class="sd">        :rtype: Series(dtype: object)</span>
<span class="sd">        :return: The type of geometry, e.g. &quot;ST_LINESTRING&quot;, &quot;ST_POLYGON&quot;, &quot;ST_POINT&quot;, &quot;ST_MULTIPOINT&quot;</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.geometry_type</span>
<span class="sd">        0      ST_POINT</span>
<span class="sd">        1    ST_POLYGON</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_GeometryType</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the centroid of each geometry.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: The centroid of geometries.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.centroid</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        1    POINT (2 2)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Centroid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry, compute the smallest convex geometry</span>
<span class="sd">        that encloses all geometries in it.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: Convex Geometries.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.convex_hull</span>
<span class="sd">        0                        POINT (1 1)</span>
<span class="sd">        1    POLYGON ((1 1,1 3,3 3,3 1,1 1))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_ConvexHull</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">npoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the points number for each geometry.</span>

<span class="sd">        :rtype: Series(dtype: int)</span>
<span class="sd">        :return: The number of points for each geometry.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.npoints</span>
<span class="sd">        0    1</span>
<span class="sd">        1    5</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_NPoints</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">envelope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the double-precision minimum bounding box geometry for each geometry.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: bounding box geometries</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;, &quot;POLYGON ((1 1, 3 1, 3 3, 1 3, 1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.envelope</span>
<span class="sd">        0                        POINT (1 1)</span>
<span class="sd">        1    POLYGON ((1 1,1 3,3 3,3 1,1 1))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Envelope</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related unary methods, which return GeoSeries</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="GeoSeries.curve_to_line"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.curve_to_line.html#arctern.GeoSeries.curve_to_line">[文档]</a>    <span class="k">def</span> <span class="nf">curve_to_line</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert curves in each geometry to approximate linear representation,</span>
<span class="sd">        e.g., CIRCULAR STRING to regular LINESTRING, CURVEPOLYGON to POLYGON,</span>
<span class="sd">        and MULTISURFACE to MULTIPOLYGON. Useful for outputting to devices</span>
<span class="sd">        that can&#39;t support CIRCULARSTRING geometry types.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: Converted geometries</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; rst = s.curve_to_line().to_wkt()</span>
<span class="sd">        &gt;&gt;&gt; assert str(rst[0]).startswith(&quot;POLYGON&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_CurveToLine</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.to_crs"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.to_crs.html#arctern.GeoSeries.to_crs">[文档]</a>    <span class="k">def</span> <span class="nf">to_crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform each geometry to a different coordinate reference system.</span>
<span class="sd">        The ``crs`` attribute on the current GeoSeries must be set.</span>

<span class="sd">        :type crs: string</span>
<span class="sd">        :param crs: Coordinate Reference System of the geometry objects.</span>
<span class="sd">                    Must be SRID formed, e.g. &quot;EPSG:4326&quot;</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: Geometries with transformed coordinate reference system.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1 2)&quot;], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POINT (1 2)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &gt;&gt;&gt; s.to_crs(crs=&quot;EPSG:3857&quot;)</span>
<span class="sd">        0    POINT (111319.490793274 222684.208505545)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not transform with invalid crs&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not transform geometries without crs. Set crs for this GeoSeries first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">crs</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Transform</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">crs</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.simplify"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.simplify.html#arctern.GeoSeries.simplify">[文档]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a &quot;simplified&quot; version for each geometry using the Douglas-Peucker algorithm.</span>

<span class="sd">        :type: tolerance: float</span>
<span class="sd">        :param tolerance: The maximum distance between a point on a linestring and a curve.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: Simplified geometries.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POLYGON ((1 1,1 2,2 2,2 1,1 1))&quot;, &quot;CIRCULARSTRING (0 0,1 1,2 0)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.simplify(1)</span>
<span class="sd">        0    POLYGON ((1 1,1 2,2 2,2 1,1 1))</span>
<span class="sd">        1               LINESTRING (0 0,2 0)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_SimplifyPreserveTopology</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.buffer"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.buffer.html#arctern.GeoSeries.buffer">[文档]</a>    <span class="k">def</span> <span class="nf">buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each geometry, returns a geometry that represents all points</span>
<span class="sd">        whose distance from this geos is less than or equal to &quot;distance&quot;.</span>

<span class="sd">        :type distance: float</span>
<span class="sd">        :param distance: he maximum distance of the returned geometry from each geometry.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: Geometries.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (0 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.buffer(0)</span>
<span class="sd">        0    POLYGON EMPTY</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Buffer</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.precision_reduce"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.precision_reduce.html#arctern.GeoSeries.precision_reduce">[文档]</a>    <span class="k">def</span> <span class="nf">precision_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For the coordinates of each geometry, reduce the number of significant digits</span>
<span class="sd">        to the given number. The last decimal place will be rounded.</span>

<span class="sd">        :type precision: int</span>
<span class="sd">        :param precision: The number of significant digits.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: Geometries with reduced precision.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT (1.333 2.666)&quot;, &quot;POINT (2.655 4.447)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.precision_reduce(3)</span>
<span class="sd">        0    POINT (1.33 2.67)</span>
<span class="sd">        1    POINT (2.66 4.45)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_PrecisionReduce</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.make_valid"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.make_valid.html#arctern.GeoSeries.make_valid">[文档]</a>    <span class="k">def</span> <span class="nf">make_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a valid representation of each geometry without losing any of the input vertices.</span>

<span class="sd">        If the geometry is already-valid, then nothing will be done. If the geometry can&#39;t be</span>
<span class="sd">        made to valid, it will be set to None value.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: Geometries that are made to valid.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POLYGON ((2 1,3 1,3 2,2 2,2 8,2 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.make_valid()</span>
<span class="sd">        0    GEOMETRYCOLLECTION (POLYGON ((2 2,3 2,3 1,2 1,2 2)),LINESTRING (2 2,2 8))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_unary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_MakeValid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.unary_union"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.unary_union.html#arctern.GeoSeries.unary_union">[文档]</a>    <span class="k">def</span> <span class="nf">unary_union</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a geometry that represents the union of all geometries in the GeoSeries.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: A GeoSeries contains only one geometry.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p1 = &quot;POINT(1 2)&quot;</span>
<span class="sd">        &gt;&gt;&gt; p2 = &quot;POINT(1 1)&quot;</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([p1, p2])</span>
<span class="sd">        &gt;&gt;&gt; s.union_aggr()</span>
<span class="sd">        0    MULTIPOINT (1 2,1 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Union_Aggr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="GeoSeries.envelope_aggr"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.envelope_aggr.html#arctern.GeoSeries.envelope_aggr">[文档]</a>    <span class="k">def</span> <span class="nf">envelope_aggr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the double-precision minimum bounding box geometry for the union of all geometries.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: A GeoSeries contains only one geometry.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p1 = &quot;POLYGON ((0 0,4 0,4 4,0 4,0 0))&quot;</span>
<span class="sd">        &gt;&gt;&gt; p2 = &quot;POLYGON ((5 1,7 1,7 2,5 2,5 1))&quot;</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([p1, p2])</span>
<span class="sd">        &gt;&gt;&gt; s.envelope_aggr()</span>
<span class="sd">        0    POLYGON ((0 0,0 4,7 4,7 0,0 0))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Envelope_Aggr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related binary methods, which return Series[bool/float]</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="GeoSeries.intersects"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.intersects.html#arctern.GeoSeries.intersects">[文档]</a>    <span class="k">def</span> <span class="nf">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether each geometry intersects other (elementwise).</span>

<span class="sd">        :type other: scalar bytes object geometry or GeoSeries</span>
<span class="sd">        :param other: The geometries to test if is intersected.</span>
<span class="sd">                      Can be scalar WKB formed bytes object, or a GeoSeries.</span>

<span class="sd">        :rtype : Series(dtype: bool)</span>
<span class="sd">        :return: A Series with value True if intersected.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.intersects(s1)</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Alternatively other can be ca scalar bytes object.</span>

<span class="sd">        &gt;&gt;&gt; s2.intersects(s1[0])</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Intersects</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.within"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.within.html#arctern.GeoSeries.within">[文档]</a>    <span class="k">def</span> <span class="nf">within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether each geometry is within other (elementwise).</span>


<span class="sd">        :type other: scalar bytes object geometry or GeoSeries</span>
<span class="sd">        :param other: The geometries to test if each geometry is within.</span>
<span class="sd">                      Can be scalar WKB formed bytes object, or a GeoSeries.</span>

<span class="sd">        :rtype: Series(dtype: bool)</span>
<span class="sd">        :return: A Series with value True if each geometry is within other.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.within(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Within</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.contains"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.contains.html#arctern.GeoSeries.contains">[文档]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether each geometry contains other (elementwise).</span>

<span class="sd">        :type other: scalar bytes object geometry or GeoSeries</span>
<span class="sd">        :param other: The geometries to test if each geometry is contained.</span>
<span class="sd">                      Can be scalar WKB formed bytes object, or a GeoSeries.</span>

<span class="sd">        :rtype: Series(dtype: bool)</span>
<span class="sd">        :return: A Series with value True if each geometry contains other.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.contains(s1)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Contains</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.crosses"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.crosses.html#arctern.GeoSeries.crosses">[文档]</a>    <span class="k">def</span> <span class="nf">crosses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether each geometry and other(elementwise) &quot;spatially cross&quot;.</span>

<span class="sd">        &quot;Spatially cross&quot; here means two geometries have</span>
<span class="sd">        some, but not all interior points in common. The intersection of the</span>
<span class="sd">        interiors of the geometries must not be the empty set and must have</span>
<span class="sd">        a dimensionality less than the maximum dimension of the two input geometries.</span>

<span class="sd">        :type other: scalar bytes object geometry or GeoSeries</span>
<span class="sd">        :param other: The geometries to test if cross.</span>
<span class="sd">                      Can be scalar WKB formed bytes object, or a GeoSeries.</span>

<span class="sd">        :rtype: Series(dtype: bool)</span>
<span class="sd">        :return: A Series with value True if each geometry crosses other.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.crosses(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Crosses</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.geom_equals"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.geom_equals.html#arctern.GeoSeries.geom_equals">[文档]</a>    <span class="k">def</span> <span class="nf">geom_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether each geometry is &quot;spatially equal&quot; to other.</span>

<span class="sd">        &quot;Spatially equal&quot; means two geometries represent the same geometry structure.</span>

<span class="sd">        :type other: scalar bytes object geometry or GeoSeries</span>
<span class="sd">        :param other: The geometries to test if each geometry is equals.</span>
<span class="sd">                      Can be scalar WKB formed bytes object, or a GeoSeries.</span>

<span class="sd">        :rtype: Series(dtype: bool)</span>
<span class="sd">        :return: A Series with value True if each geometry is spatially equals to other.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.geom_equals(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">is_scalar</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">other</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">this</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The indices of the two GeoSeries are different.&quot;</span><span class="p">)</span>
            <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Equals</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">other_na</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        <span class="n">result</span><span class="p">[</span><span class="n">other_na</span> <span class="o">&amp;</span> <span class="n">this</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="GeoSeries.touches"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.touches.html#arctern.GeoSeries.touches">[文档]</a>    <span class="k">def</span> <span class="nf">touches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether each geometry &quot;touches&quot; other.</span>

<span class="sd">        &quot;Touch&quot; means two geometries have common points, and the</span>
<span class="sd">        common points locate only on their boundaries.</span>

<span class="sd">        :type other: scalar bytes object geometry or GeoSeries</span>
<span class="sd">        :param other: The geometries to test if each geometry is touched.</span>
<span class="sd">                      Can be scalar WKB formed bytes object, or a GeoSeries.</span>

<span class="sd">        :rtype: Series(dtype: bool)</span>
<span class="sd">        :return: A Series with value True if each geometry touches other.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.touches(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Touches</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.overlaps"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.overlaps.html#arctern.GeoSeries.overlaps">[文档]</a>    <span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether each geometry &quot;spatially overlaps&quot; other.</span>

<span class="sd">        &quot;Spatially overlap&quot; here means two geometries intersect</span>
<span class="sd">        but one does not completely contain another.</span>

<span class="sd">        :type other: scalar bytes object geometry or GeoSeries</span>
<span class="sd">        :param other: The geometries to test if each geometry overlaps.</span>
<span class="sd">                      Can be scalar WKB formed bytes object, or a GeoSeries.</span>

<span class="sd">        :rtype: Series(dtype: bool)</span>
<span class="sd">        :return: A Series with value True if each geometry overlaps other.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0,1 0,1 1,0 1,0 0))&quot;, &quot;POLYGON((8 0,9 0,9 1,8 1,8 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;, &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.overlaps(s1)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Overlaps</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.distance"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.distance.html#arctern.GeoSeries.distance">[文档]</a>    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the minimum 2D Cartesian (planar) distance between each geometry and other.</span>

<span class="sd">        :type other: scalar bytes object geometry or GeoSeries</span>
<span class="sd">        :param other: The geometries to calculate the distance to each geometry.</span>
<span class="sd">                      Can be scalar WKB formed bytes object, or a GeoSeries.</span>

<span class="sd">        :rtype: Series(dtype: float64)</span>
<span class="sd">        :return: A Series contains the distances between each geometry and other.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; p11 = &quot;LINESTRING(9 0,9 2)&quot;</span>
<span class="sd">        &gt;&gt;&gt; p12 = &quot;POINT(10 2)&quot;</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([p11, p12])</span>
<span class="sd">        &gt;&gt;&gt; p21 = &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;</span>
<span class="sd">        &gt;&gt;&gt; p22 = &quot;POLYGON((0 0,0 8,8 8,8 0,0 0))&quot;</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([p21, p22])</span>
<span class="sd">        &gt;&gt;&gt; s2.distance(s1)</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    2.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Distance</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.distance_sphere"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.distance_sphere.html#arctern.GeoSeries.distance_sphere">[文档]</a>    <span class="k">def</span> <span class="nf">distance_sphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return minimum distance in meters between two lon/lat points.</span>

<span class="sd">        Uses a spherical earth and radius derived from the spheroid defined by the SRID.</span>
<span class="sd">        Only &#39;EPSG:4326&#39; can calculate spherical distance.</span>

<span class="sd">        :type other: scalar bytes object geometry or GeoSeries</span>
<span class="sd">        :param other: The geometries to calculate the spherical distance to each geometry.</span>
<span class="sd">                      Can be scalar WKB formed bytes object, or a GeoSeries.</span>
<span class="sd">                      If other is scalar bytes object, we will assume other&#39;s crs is &#39;EPSG:4326&#39;.</span>

<span class="sd">        :rtype: Series(dtype: float64)</span>
<span class="sd">        :return: A Series contains the spherical distance between each geometry and other.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POINT(10 2)&quot;], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POINT(10 3)&quot;], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s2.distance_sphere(s1)</span>
<span class="sd">        0    111226.3</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;crs&quot;</span><span class="p">,</span> <span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;EPSG:4326&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only can calculate spherical distance with &#39;EPSG:4326&#39; crs.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_DistanceSphere</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.hausdorff_distance"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.hausdorff_distance.html#arctern.GeoSeries.hausdorff_distance">[文档]</a>    <span class="k">def</span> <span class="nf">hausdorff_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Hausdorff distance between each geometry and other.</span>

<span class="sd">        This is a measure of how similar or dissimilar 2 geometries are.</span>

<span class="sd">        :type other: scalar bytes object geometry or GeoSeries</span>
<span class="sd">                     Can be scalar WKB formed bytes object, or a GeoSeries.</span>
<span class="sd">        :param other: The geometries to calculate the hausdorff distance to each geometry.</span>

<span class="sd">        :rtype: Series(dtype: float64)</span>
<span class="sd">        :return : A Series contains the hausdorff distance between each geometry and other.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON((0 0 ,0 1, 1 1, 1 0, 0 0))&quot;, &quot;POINT(0 0)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON((0 0 ,0 2, 1 1, 1 0, 0 0))&quot;, &quot;POINT(0 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.hausdorff_distance(s1)</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    1.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_HausdorffDistance</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Geometry related binary methods, which return GeoSeries</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="GeoSeries.intersection"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.intersection.html#arctern.GeoSeries.intersection">[文档]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the point set intersection between each geometry and other.</span>

<span class="sd">        :type other: scalar bytes object geometry or GeoSeries.</span>
<span class="sd">                      Can be scalar WKB formed bytes object, or a GeoSeries.</span>
<span class="sd">        :param other: The geometries to calculate the intersection point set between each geometry.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: A GeoSeries contains geometries.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s1 = GeoSeries([&quot;POLYGON ((1 1,1 2,2 2,2 1,1 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries([&quot;POLYGON ((2 1,3 1,3 2,2 2,2 1))&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s2.intersection(s1)</span>
<span class="sd">        0    LINESTRING (2 2,2 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_binary_geo</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Intersection</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># utils</span>
    <span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="GeoSeries.to_wkt"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.to_wkt.html#arctern.GeoSeries.to_wkt">[文档]</a>    <span class="k">def</span> <span class="nf">to_wkt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform each geometry to WKT formed string.</span>

<span class="sd">        :rtype: Series(dtype: object)</span>
<span class="sd">        :return: A Series contains geometries as WKT formed string.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &gt;&gt;&gt; s.to_wkt()</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_AsText</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.to_wkb"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.to_wkb.html#arctern.GeoSeries.to_wkb">[文档]</a>    <span class="k">def</span> <span class="nf">to_wkb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform each geometry to WKB formed bytes object.</span>

<span class="sd">        :rtype: Series(dtype: object)</span>
<span class="sd">        :return: A Series contains geometries as WKB formed bytes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.as_geojson"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.as_geojson.html#arctern.GeoSeries.as_geojson">[文档]</a>    <span class="k">def</span> <span class="nf">as_geojson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform each to GeoJSON format string.</span>

<span class="sd">        :rtype: Series(dtype: object)</span>
<span class="sd">        :return: A Series contains geometries as GeoJSON formed string.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &gt;&gt;&gt; s.as_geojson()</span>
<span class="sd">        0    { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [ 1.0, 1.0 ] }</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_property_op</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_AsGeoJSON</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">to_geopandas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform each arctern GeoSeries to GeoPandas GeoSeries.</span>

<span class="sd">        :rtype: GeoPandas GeoSeries(dtype: geometry)</span>
<span class="sd">        :return: A GeoPandas GeoSeries.</span>
<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([&quot;POINT(1 1)&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POINT (1 1)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &gt;&gt;&gt; s.to_geopandas()</span>
<span class="sd">        0    POINT (1.00000 1.00000)</span>
<span class="sd">        dtype: geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">geopandas</span>
        <span class="kn">import</span> <span class="nn">shapely</span>

        <span class="k">return</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">wkb</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

<div class="viewcode-block" id="GeoSeries.polygon_from_envelope"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.polygon_from_envelope.html#arctern.GeoSeries.polygon_from_envelope">[文档]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">polygon_from_envelope</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct polygon(rectangle) geometries from arr_min_x, arr_min_y, arr_max_x,</span>
<span class="sd">        arr_max_y and special coordinate system. The edges of polygon are parallel to coordinate axis.</span>

<span class="sd">        :type min_x: Series(dtype: float64)</span>
<span class="sd">        :param min_x: The minimum value of x coordinate of the rectangles.</span>

<span class="sd">        :type min_y: Series(dtype: float64)</span>
<span class="sd">        :param min_y: The minimum value of y coordinate of the rectangles.</span>

<span class="sd">        :type max_x: Series(dtype: float64)</span>
<span class="sd">        :param max_x: The maximum value of x coordinate of the rectangles.</span>

<span class="sd">        :type max_y: Series(dtype: float64)</span>
<span class="sd">        :param max_y: The maximum value of y coordinate of the rectangles.</span>

<span class="sd">        :type crs: string, optional</span>
<span class="sd">        :param crs: Must be SRID format string.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: A GeoSeries contains geometries.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from pandas import Series</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; min_x = Series([0.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; max_x = Series([2.0, 1.5])</span>
<span class="sd">        &gt;&gt;&gt; min_y = Series([0.0, 1.0])</span>
<span class="sd">        &gt;&gt;&gt; max_y = Series([1.0, 1.5])</span>
<span class="sd">        &gt;&gt;&gt; GeoSeries.polygon_from_envelope(min_x, min_y, max_x, max_y)</span>
<span class="sd">        0                POLYGON ((0 0,0 1,2 1,2 0,0 0))</span>
<span class="sd">        1    POLYGON ((1 1,1.0 1.5,1.5 1.5,1.5 1.0,1 1))</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_PolygonFromEnvelope</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.point"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.point.html#arctern.GeoSeries.point">[文档]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">point</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct Point geometries according to the coordinates.</span>

<span class="sd">        :type x: Series(dtype: float64)</span>
<span class="sd">        :param x: Abscissa of the point.</span>

<span class="sd">        :type y: Series(dtype: float64)</span>
<span class="sd">        :param y: Ordinate of the point.</span>

<span class="sd">        :type crs: string, optional</span>
<span class="sd">        :param crs: Must be SRID format string.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: A GeoSeries contains point geometries.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from pandas import Series</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; x = Series([1.3, 2.5])</span>
<span class="sd">        &gt;&gt;&gt; y = Series([1.3, 2.5])</span>
<span class="sd">        &gt;&gt;&gt; GeoSeries.point(x, y)</span>
<span class="sd">        0    POINT (1.3 1.3)</span>
<span class="sd">        1    POINT (2.5 2.5)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeoSeries.geom_from_geojson"><a class="viewcode-back" href="../../../api_reference/standalone_api/api/arctern.GeoSeries.geom_from_geojson.html#arctern.GeoSeries.geom_from_geojson">[文档]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">geom_from_geojson</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct geometry from the GeoJSON representation string.</span>

<span class="sd">        :type json: Series(dtype: object)</span>
<span class="sd">        :param json: Geometries in json format.</span>

<span class="sd">        :type crs: string, optional</span>
<span class="sd">        :param crs: Must be SRID format string.</span>

<span class="sd">        :rtype: GeoSeries</span>
<span class="sd">        :return: A GeoSeries contains geometries.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; from pandas import Series</span>
<span class="sd">        &gt;&gt;&gt; from arctern import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; json = Series([&quot;{\&quot;type\&quot;:\&quot;LineString\&quot;,\&quot;coordinates\&quot;:[[1,2],[4,5],[7,8]]}&quot;])</span>
<span class="sd">        &gt;&gt;&gt; GeoSeries.geom_from_geojson(json)</span>
<span class="sd">        0    LINESTRING (1 2,4 5,7 8)</span>
<span class="sd">        dtype: GeoDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">_validate_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">arctern</span><span class="o">.</span><span class="n">ST_GeomFromGeoJSON</span><span class="p">(</span><span class="n">json</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_geopandas</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct geometries from geopandas GeoSeries.</span>

<span class="sd">        :rtype data: geopandas.GeoSeries</span>
<span class="sd">        :param data: Source geometries data.</span>

<span class="sd">        :rtype: arctern.GeoSeries</span>
<span class="sd">        :return: A arctern.GeoSeries constructed from geopandas.GeoSeries.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
        <span class="kn">import</span> <span class="nn">shapely.wkb</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;data must be </span><span class="si">{</span><span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_authority</span><span class="p">()</span> <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">source_crs</span><span class="o">.</span><span class="n">to_authority</span><span class="p">()</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="n">crs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">crs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span>
            <span class="k">return</span> <span class="n">shapely</span><span class="o">.</span><span class="n">wkb</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, zilliz
      <span class="lastupdated">
        最后更新于 6月 06, 2020.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>